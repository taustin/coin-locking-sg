"use strict";

const Blockchain = require('./blockchain.js');
const Client = require('./client.js');

module.exports = class LockingClient extends Client {

  constructor(...args) {
    super(...args);
  }

  /**
   * Broadcasts a transaction where the client locks gold in order to
   * create gold for the clients specified in 'outputs'. The transaction
   * fee is also generated by locking gold.
   * 
   * @param {Array} outputs - The list of outputs of other addresses and
   *    amounts of gold to lock for each output.
   * @param {number} [fee] - The amount of gold locked to generate the transaction fee.
   */
  postLockingTransaction(outputs, fee=Blockchain.DEFAULT_TX_LOCK_FEE) {
    // We calculate the total value of gold needed.
    let totalPayments = outputs.reduce((acc, {amount}) => acc + amount, 0) + fee;

    // Make sure the client has enough gold.
    if (totalPayments > this.availableGold) {
      throw new Error(`Requested ${totalPayments}, but account only has ${this.balance}.`);
    }

    // Broadcasting the new transaction.
    let tx = Blockchain.makeTransaction({
      from: this.address,
      nonce: this.nonce,
      pubKey: this.keyPair.public,
      outputs: [],
      fee: 0,
      data: {
        lockingOutputs: outputs,
        lockingFee: fee,
      },
    });

    tx.sign(this.keyPair.private);

    // Adding transaction to pending.
    this.pendingOutgoingTransactions.set(tx.id, tx);

    this.nonce++;

    this.log(`Posting transaction ${tx.id}`);

    this.net.broadcast(Blockchain.POST_TRANSACTION, tx);

    return tx;
  }

  /**
   * In addition to the usual issues with determining what gold is available,
   * with the coin-locking model we must also consider how much gold is
   * currently locked.
   */
  get availableGold() {
    return super.availableGold - this.lockedGold();
  }

  /**
   * Returns the amount of gold currently locked.
   */
  lockedGold() {
    return this.lastConfirmedBlock.lockedGold(this.address);
  }

  /**
   * Utility method that displays all confimed balances for all clients,
   * according to the client's own perspective of the network.
   */
  showAllBalances() {
    this.log("Showing balances:");
    for (let [id,balance] of this.lastConfirmedBlock.balances) {
      console.log(`    ${id}: ${balance} (${this.lastConfirmedBlock.lockedGold(id)} locked)`);
    }
  }
};
